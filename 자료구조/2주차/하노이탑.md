<div align="center">
  <h2> 하노이탑 </h2>
</div>


## n=5개일 때의 3단계 과정
### 초기상태
```
- A막대에 5개의 원판이 있고, B와 C는 빈 상태
- 목표는 A에 있는 5개의 원판을 C로 옮기는 것, 이 과정은 재귀적으로 이루어짐
```
### 🗼 1단계: A에 있는 4개의 원판을 임시로 C를 이용해 B로 옮기기
### 🗼 1단계: A에 남아있는 n-1개의 원판을 임시로 C로 이용해 B로 옮기기
#### 먼저 A에 있는 가장 큰 원판, 5번 원판을 옮기기 위해, 그 위에 있는 4개의 원판 B로 옮겨야 함
```
- 4개의 원판을 B로 옮기는 것은 다시 작은 하노이탑 문제 = 재귀함수 호출
여기서는 n=4로 생각하고, 같은 재귀과정을 거침
  1. 4개의 원판 중 3개를 A에서 C로 옮김(B 임시로 이용)
  A에 남아있는 1개의 원판, 4번 원판을 B로 옮겨야 하기 때문 
  2. A에 남은 1개의 원판을 B로 옮김
  3. C에 남은 3개의 원판을 A를 임시로 이용해 B로 옮김
이 과정이 끝나면 A에는 가장 큰 원판 5번 하나만 남아있고, B에는 4개의 원판이 순서대로 쌓여있음
```
### 🗼 2단계: A에 남아있는 가장 큰 원판, 5번 원판을 C로 옮기기
### 🗼 2단계: A에 남아있는 가장 큰 원판을 C로 옮김 
```
이제 A에 남아있는 가장 큰 원판, 5번 원판을 C로 옮김, 원판 하나만 옮기면 됨
```
### 🗼 3단계: B에 있는 4개의 원판을 임시로 A로 이용해 C로 옮기기 
### 🗼 3단계: B에 있는 n-1개의 원판을 임시로 A로 이용해 C로 옮김 
```
이제 B에 있는 4개의 원판을 C로 옴겨야 함, 이 과정은 다시 하노이탑 문제 (n=4)로 돌아가서 해결
이때 n=4로 문제를 다시 나누어 해결, 똑같이 1-3단계로 진행됨
```
#### 다시 n=4로 돌아가서 과정
```
1단계: B에 있는 3개의 원판을 A를 임시로 이용해 C로 옮김
2단계: B에 남아있는 1개의 원판 C로 옮김
3단계: A에 남아있는 3개의 원판을 B를 임시로 이용해 C로 옮김 
```
## 🔵 코드 구현 
```
def hanoi_tower(n, fr, tmp, to):
    if n == 1:  # 기저 조건: 원판이 1개일 때, 하나의 원판을 fr에서 to로 옮김 
        print("원판 1: %s --> %s" % (fr, to))
    else:
        hanoi_tower(n - 1, fr, to, tmp)  # n-1개의 원판을 임시로 옮김
        print("원판 %d: %s --> %s" % (n, fr, to))  # 가장 큰 원판을 옮김
        hanoi_tower(n - 1, tmp, fr, to)  # 다시 n-1개의 원판을 최종 위치로 옮김

# 예시: 4개의 원판이 있을 때
hanoi_tower(4, 'A', 'B', 'C')
```
### 기저조건: 재귀호출 멈추고, 바로 결과를 반환하는 조건 
```
- n: 옮겨야 할 원판의 개수
- fr: 시작 막대, 현재 원판이있는 곳
- tmp: 임시로 사용할 보조 막대
- to: 최종족으로 원판을 옮길 목적지 막대
```
### print("원판 1: %s --> %s" % (fr, to)
```
원판이 하나일 때, 출발 막대 fr에서 목적지 to로 옮긴다는 메세지 출력 
```
### else:
```
n이 1보다 클 때, 원판이 2개 이상일 때는 재귀호출 이용해 더 작은 문제로 나누어 해석
```
### hanoi_tower(n - 1, fr, to, tmp)  # n-1개의 원판을 임시로 옮김
```
가장 큰 원판 n번원판 옮기기 전에, 그 위에 있는 n-1개의 원판을 임시로 tmp 막대로 옮김
여기서는 to 막대가 임시로 사용됨, 이 호출은 더 작은 하노이탑 문제를 해결하기 위해 재귀적으로 실행
```
### print("원판 %d: %s --> %s" % (n, fr, to))  # 가장 큰 원판을 옮김
```
가장 큰 원판 n번 원판을 출발지 fr에서 목적지 to로 옮긴다는 메세지 출력
```
## 🔵 하노이탑 문제와 시간복잡도 분석
```
- 먼저 n-1개의 원판 임시 막대 B로 옮김
- 그 다음 가장 큰 원판 목표 막대 C로 옮김
- 마지막으로 n-1개의 원판을 다시 임시 막대 B에서 목표 막대 C로 옮김
```
### 재귀적 관계
#### T(n)은 n개의 원판을 옮기는데 필요한 최소횟수
#### T(n-1)은 n-1개의 원판을 옮기는데 필요한 최소횟수
```
1. n-1개의 원판을 임시막대 B로 옮김, 이 작업은 T(n-1)번의 이동 필요
2. 가장 큰 n번째 원판을 목표 막대 C로 옮김, 이때 1번의 이동 발생
3. 임시 막대 B에 있는 n-1개의 원판 다시 목표 막대 C로 옮김, 이때 T(n-1)번의 이동 필요
```
<div align="center">
  <h3> T(n) = T(n-1) + 1 + T(n-1)</h3>
</div>

<div align="center">
  <h3> T(n) = 2T(n-1) + 1</h3>
</div>


### T(n-1) = 2T(n-2)+1
```
T(n) = 2(2T(n-2)+1) + 1
따라서
2^2T(n-2) + 2^1 + 2^0
```
### T(n-2) = 2T(n-3) + 1
```
T(n) = 2(2(2T(n-3)+1)+1) + 1
따라서
2^3T(n-3) + 2^2 + 2^1 + 2^0
```
### 마지막 항이 2^n-1T(1)인 이유: T(n)은 계속해서 2 X T(이전단계), n-1의 대체 과정을 거치기 때문
<div align="center">
  <h3> T(n) = 2^n-1T(1) + (2^n-2 + 2^n-3 + ''' + 2^1 + 2^0)</h3>
</div>

### 등비수열 정리
```
S = 2^0 + 2^1 + 2^2 + ... + 2^n-2 = 2^n-1 - 1
첫 번째 항이 1이고, 공비가 2인 등비수열 a=1, r=2, 항의 개수는 n-1
```
### 최종적인 공식 
<div align="center">
  <h3> 2^n - 1</h3>
</div>

### 복잡도 표기
<div aling="center">
  <h3>0(2^n)</h3>
</div>










